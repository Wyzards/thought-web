<!DOCTYPE html>
<html lang="en">
	<head>
		<link rel="manifest" href="manifest.json" />
		<meta name="theme-color" content="#4a90e2" />
		<meta charset="UTF-8" />
		<title>Thought Web Prototype</title>
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<style>
			html,
			body {
				margin: 0;
				padding: 0;
				height: 100%;
				font-family: sans-serif;
			}

			#container {
				display: flex;
				flex-direction: column;
				height: 100vh;
			}

			#editModal {
				position: fixed;
				top: 0;
				left: 0;
				width: 100vw;
				height: 100vh;
				background: rgba(0, 0, 0, 0.6);
				display: none;
				align-items: center;
				justify-content: center;
				z-index: 10001;
			}

			#editModalContent {
				background: white;
				padding: 20px;
				border-radius: 8px;
				width: 90%;
				max-width: 500px;
				box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
				display: flex;
				flex-direction: column;
				gap: 10px;
			}

			#editModalContent textarea {
				width: 100%;
				height: 100px;
				font-size: 14px;
			}

			#searchModal {
				position: absolute;
				top: 100%;
				left: 0;
				width: 100%;
				max-height: 300px;
				overflow-y: auto;
				background-color: #2a2a2a;
				border: 1px solid #444;
				border-radius: 4px;
				color: #fff;
				box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5);
				z-index: 999;
			}

			#searchModal .result {
				padding: 10px;
				cursor: pointer;
				border-bottom: 1px solid #444;
			}

			#searchModal .result:hover {
				background-color: #3a3a3a;
			}

			#searchModal.visible {
				display: flex;
				flex-wrap: wrap;
				align-items: center;
				gap: 6px;
			}

			#searchModal input[type="text"]::placeholder,
			#searchModal textarea::placeholder {
				color: #bbb;
			}

			#searchBar {
				width: 100%;
				padding: 10px;
				font-size: 16px;
				background-color: #2a2a2a;
				color: #ffffff;
				border: 1px solid #444;
				border-radius: 4px;
				box-sizing: border-box;
			}

			#searchModal input {
				flex: 1;
				min-width: 0;
			}

			#searchModal button {
				padding: 8px 12px;
				font-size: 16px;
				width: auto;
			}

			#searchToolbar {
				display: flex;
				flex-wrap: wrap;
				justify-content: center;
				align-items: center;
				gap: 6px;
				padding: 8px;
				background-color: #1e1e1e; /* optional: to distinguish the toolbar from modal background */
				border-bottom: 1px solid #444; /* subtle divider if needed */
			}

			#searchInput {
				width: 180px;
				max-width: 60vw;
				padding: 8px 10px;
				font-size: 16px;
				background-color: #2a2a2a;
				color: #ffffff;
				border: 1px solid #444;
				border-radius: 4px;
				box-sizing: border-box;
			}

			#searchInput::placeholder {
				color: #aaa;
			}

			#graph-container {
				flex-grow: 1;
				width: 100%;
				position: relative;
				width: 100%;
				height: 100vh;
				overflow: hidden;
			}
			
			#bg-layer {
			  position: absolute;
			  width: 100%;
			  height: 100%;
			  background-image: url('space.jpg');
			  background-repeat: repeat;
			  background-size: cover;
			  z-index: 0;
			  filter: brightness(0.5); /* Darken the background */
			}
			
			#glow-canvas {
				position: absolute;
				top: 0;
				left: 0;
				pointer-events: none;
				z-index: 1;
			}

			#cy {
				position: absolute;
				width: 100%;
				height: 100%;
				z-index: 2;
				background: transparent;
			}
			
			#controls {
				position: relative;
				width: 100%;
				background: #1e1e1e;
				padding: 10px;
				box-sizing: border-box;
				display: flex;
				flex-direction: column;
				gap: 10px;
				flex-shrink: 0;
				color: #fff;
			}

			#controls > textarea,
			#controls > button {
				width: 100%;
				font-size: 16px;
				padding: 12px;
				box-sizing: border-box;
				background-color: #2a2a2a;
				color: #ffffff;
				border: 1px solid #444;
				border-radius: 4px;
			}

			#controls > button:hover {
				background-color: #333;
				cursor: pointer;
			}

			#controls > textarea::placeholder {
				color: #bbb;
			}


			@media (min-width: 768px) {
				#container {
					flex-direction: row;
				}

				#controls {
					width: 300px;
					height: 100vh;
					border-right: 1px solid #ccc;
				}

				#cy {
					height: 100vh;
				}
			}

			#promptButton {
				position: fixed;
				bottom: 20px;
				right: 20px;
				background: #4a90e2;
				color: white;
				border: none;
				border-radius: 50%;
				width: 56px;
				height: 56px;
				font-size: 24px;
				display: none;
				justify-content: center;
				align-items: center;
				z-index: 999;
				box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
			}

			#promptModal {
				position: fixed;
				top: 0;
				left: 0;
				width: 100vw;
				height: 100vh;
				background: rgba(0, 0, 0, 0.6);
				display: none;
				align-items: center;
				justify-content: center;
				z-index: 10000;
			}

			#modalContent {
				background: white;
				padding: 20px;
				border-radius: 8px;
				width: 90%;
				max-width: 500px;
				box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
				display: flex;
				flex-direction: column;
				gap: 10px;
			}

			#modalContent textarea {
				width: 100%;
				height: 100px;
				margin-bottom: 10px;
				font-size: 14px;
			}

			.ghost-node {
				background-color: #aaa !important;
				border-style: dashed;
				opacity: 0.8;
			}
			
			#textMeasurer {
			  position: absolute;
			  visibility: hidden;
			  font-size: 12px;
			  font-family: sans-serif;
			  line-height: 1.2;
			  padding: 4px;
			  box-sizing: border-box;
			  white-space: normal;
			  word-wrap: break-word;
			  width: auto;
			  max-width: none;
			  display: inline-block;
			}
		</style>
	</head>

	<body>
		<div id="container">
			<div id="controls">
				<textarea id="thoughtInput" placeholder="Enter a new thought..."></textarea>
				<button onclick="addNode()">Add New Thought</button>
				<button onclick="addLinkedNode()">Add Linked Thought</button>
				<button onclick="linkNodes()">Link Selected Nodes</button>
				<button onclick="deleteSelected()">Delete Selected Node</button>
				<button onclick="toggleSearchModal()">üîç Search</button>
				<div id="searchModal" style="display: none">
					<div style="display: flex; flex-wrap: wrap; align-items: center; gap: 6px">
						<input type="text" id="searchInput" placeholder="Search text..." style="width: 60%" />
						<button onclick="prevSearchResult()">‚Üê</button>
						<span id="searchIndex">0 / 0</span>
						<button onclick="nextSearchResult()">‚Üí</button>
						<button onclick="closeSearchModal()">‚úñ</button>
					</div>
				</div>
			</div>
			<div id="graph-container">
				<div id="bg-layer"></div>
				<canvas id="glow-canvas"></canvas>
				<div id="cy"></div>
			</div>
		</div>

		<button id="promptButton" onclick="generatePromptNodes()">üí°</button>

		<div id="promptModal">
			<div id="modalContent">
				<p id="modalPromptText"></p>
				<textarea id="modalAnswer"></textarea>
				<button onclick="submitPromptAnswer()">Submit</button>
				<button onclick="closePromptModal()">Cancel</button>
			</div>
		</div>

		<div id="editModal">
			<div id="editModalContent">
				<textarea id="editNodeTextarea"></textarea>
				<button onclick="submitNodeEdit()">Submit</button>
				<button onclick="closeEditModal()">Cancel</button>
			</div>
		</div>

		<div id="textMeasurer"></div>

		<script>
			if ('serviceWorker' in navigator) {
				window.addEventListener('load', () => {
					navigator.serviceWorker.register('service-worker.js').then((registration) => {
						logDebug('SW registered');

						// Force the SW to check for updates immediately
						registration.update();

						// Listen for waiting SW
						if (registration.waiting) {
							logDebug('SW waiting. Sending skipWaiting...');
							registration.waiting.postMessage({ type: 'SKIP_WAITING' });
						}

						registration.addEventListener('updatefound', () => {
							const newWorker = registration.installing;
							logDebug('New SW found.');

							newWorker.addEventListener('statechange', () => {
								logDebug(`New SW state: ${newWorker.state}`);
								if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
									logDebug('New SW installed, refreshing to activate it...');
									window.location.reload();
								}
							});
						});
					});

					// Listen for messages from the SW
					navigator.serviceWorker.addEventListener('message', (event) => {
						logDebug(event.data);
					});
				});
			}

			function logDebug(msg) {
				// const el = document.getElementById('debugLog');
				// if (el) {
				//   const time = new Date().toLocaleTimeString();
				//   el.textContent += `[${time}] ${msg}\n`;
				//   el.scrollTop = el.scrollHeight;
				// }
				// console.log(msg);
			}
		</script>

		<!-- Add this somewhere near bottom of <body> for in-app logging -->
		<!-- <pre id="debugLog" -->
		<!-- style="position:fixed;bottom:0;left:0;right:0;max-height:150px;background:#111;color:#0f0;font-size:12px;overflow-y:auto;padding:5px;z-index:9999"></pre> -->

		<script src="https://unpkg.com/cytoscape@3.21.1/dist/cytoscape.min.js"></script>
		<script>
			let cy;
			let nodeId = 0;
			let promptId = 0;
			let selectionQueue = [];
			let activePrompts = {};
			let currentPromptParent = null;
			let currentPromptData = null;

			window.onload = () => {
				const canvas = document.getElementById('glow-canvas');
				const ctx = canvas.getContext('2d');
				
				cy = cytoscape({
					container: document.getElementById('cy'),
					elements: loadData(),
					style: [
						{
							selector: 'node',
							style: {
							  shape: 'ellipse',
							  'background-color': 'rgba(255, 255, 255, 1)', // transparent white background
							  'background-opacity': 0.2,                      // ensure it's not fully solid
							  'border-color': '#ffffff',
							  'border-width': 2,

							  // glow effect
								'shadow-blur': 30,
								'shadow-color': '#ffffff',
								'shadow-opacity': 0.2,

							  label: 'data(label)',
							  color: '#ffffff',
							  'font-size': 12,
							  'text-valign': 'center',
							  'text-halign': 'center',
							  'text-wrap': 'wrap',
							  'text-max-width': 'data(labelWidth)',
							  'width': 'data(nodeSize)',
							  'height': 'data(nodeSize)',
							  padding: '5px',

							  'z-index': 10
							}
						},
						{
						selector: 'edge',
						  style: {
							'width': 1,
							'line-color': 'rgba(255, 255, 255, 0.3)', // translucent line
							'target-arrow-color': 'rgba(255, 255, 255, 0.3)',
							'curve-style': 'bezier',
							'arrow-scale': 0.8,
							'target-arrow-shape': 'triangle',
							'z-index': 0
						  }
						},
						{
							selector: '.manual-selected',
							style: {
								'border-width': 3,
								'border-color': '#ffa500'
							}
						},
						{
							selector: '.ghost-node',
							style: {
								'background-color': '#aaa',
								'border-style': 'dashed',
								opacity: 0.8
							}
						}
					],
					layout: { name: 'preset' },
					ready: function () {
						this.nodes().ungrabify();
					},
					wheelSensitivity: 0.1
				});
				resizeCanvas();
				
				function resizeCanvas() {
				  const rect = cy.container().getBoundingClientRect();
				  canvas.width = rect.width;
				  canvas.height = rect.height;
				}
				
				function drawGlows() {
				  console.log("DrawGlows");
				  ctx.clearRect(0, 0, canvas.width, canvas.height);

				  const zoom = cy.zoom();
				  const pan = cy.pan();

					cy.nodes().forEach((node) => {
					  const pos = node.position();
					  const renderedX = pos.x * zoom + pan.x;
					  const renderedY = pos.y * zoom + pan.y;
					  // const renderedPos = cy.renderer().projectIntoViewport(pos.x, pos.y);

					  const style = node.style();
					  const nodeWidth = parseFloat(style.width);
					  const nodeHeight = parseFloat(style.height);
					  const nodeRadius = Math.max(nodeWidth, nodeHeight) / 2;
					  
					  const innerRadius = nodeRadius * zoom;
					  const outerRadius = innerRadius * 2;

					  // Create radial gradient centered on node
					  const gradient = ctx.createRadialGradient(
						renderedX,
						renderedY,
						innerRadius * 1.01,  // small bright center
						renderedX,
						renderedY,
						outerRadius         // outer edge radius
					  );

					  gradient.addColorStop(0, 'rgba(255, 255, 255, 0)');   // Bright cyan center
					  gradient.addColorStop(0.2, 'rgba(255, 255, 255, 0.3)'); // Medium glow
					  gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');     // Fully transparent edge

					  ctx.beginPath();
					  ctx.fillStyle = gradient;
					  ctx.arc(renderedX, renderedY, outerRadius, 0, 2 * Math.PI);
					  ctx.fill();
					});
				}
								
				window.addEventListener('resize', resizeCanvas);

				cy.on('zoom', () => {
				  const zoom = cy.zoom();
				  const blurAmount = Math.max(0, (1 - zoom) * 3); // More blur at lower zoom
				  const brightness = Math.max(0.15, Math.min(.5, zoom * 0.5));  // Dim when zoomed out

				  const bg = document.getElementById('bg-layer');
				  bg.style.filter = `brightness(${brightness}) blur(${blurAmount}px)`;
				});


				cy.on('pan zoom', () => {
				  const pan = cy.pan();
				  const zoom = cy.zoom();

				  // Adjust background position and scale
				  const bg = document.getElementById('bg-layer');
				  bg.style.backgroundPosition = `${pan.x}px ${pan.y}px`;
				  bg.style.backgroundSize = `${100 * zoom}%`;
				});
				
				cy.on('render zoom pan drag position add remove', () => {
				  //drawGlows();
				});

				updateNodeIdCounter();
				setupCustomSelection();
				updateLinkButtonLabel();

				cy.nodes('.manual-selected').forEach((node) => {
					if (!selectionQueue.includes(node)) {
						node.removeClass('manual-selected');
					}
				});

				let saveTimeout = null;

				cy.on('position', 'node', function (e) {
					// Save data on node position change (dragging or programmatic move)
					if (saveTimeout) clearTimeout(saveTimeout);
					saveTimeout = setTimeout(() => {
						saveData();
						saveTimeout = null;
					}, 500);
				});
			};

			let searchResults = [];
			let searchIndex = 0;

			function calculateSquareTextBoxSize(text) {
			  const measurer = document.getElementById("textMeasurer");

			  // Setup styles to match your font, padding etc
			  measurer.style.fontSize = "12px";
			  measurer.style.fontFamily = "sans-serif";
			  measurer.style.lineHeight = "1.2";
			  measurer.style.padding = "4px";
			  measurer.style.boxSizing = "border-box";
			  measurer.style.whiteSpace = "normal";
			  measurer.style.wordWrap = "break-word";
			  measurer.style.visibility = "hidden";
			  measurer.style.position = "absolute";

			  measurer.innerText = text;

			  const paddingPx = 16;

			  let min = 30;
			  let max = 300;

			  // Step 1: Increase max until height fits in square box (height <= width)
			  while (true) {
				measurer.style.width = max + "px";
				const height = measurer.scrollHeight;

				if (height <= max) break;  // found a width where it fits
				max *= 2;                  // double max and try again
			  }

			  // Step 2: Binary search between min and max to find minimal fitting square size
			  let bestWidth = max;

			  while (min <= max) {
				const mid = Math.floor((min + max) / 2);

				measurer.style.width = mid + "px";
				const height = measurer.scrollHeight;

				if (height <= mid) {
				  bestWidth = mid;
				  max = mid - 1;
				} else {
				  min = mid + 1;
				}
			  }
			  
			  const nodeSize = Math.ceil(bestWidth * Math.SQRT2);

			  return {
				labelWidth: bestWidth,
				nodeSize: nodeSize
			  };
			}


			function openEditModal() {
				if (selectionQueue.length !== 1) return;
				const selected = selectionQueue[0];
				document.getElementById('editNodeTextarea').value = selected.data('label');
				document.getElementById('editModal').style.display = 'flex';
			}

			function closeEditModal() {
				document.getElementById('editModal').style.display = 'none';
			}

			function submitNodeEdit() {
				if (selectionQueue.length !== 1) return;
				
				const newText = document.getElementById('editNodeTextarea').value.trim();
				if (!newText) return;
				
				const selected = selectionQueue[0];
				selected.data('label', newText);

				// Recalculate sizes based on new text
				  const { labelWidth, nodeSize } = calculateSquareTextBoxSize(newText);

				  // Update data fields for global style usage
				  selected.data('labelWidth', labelWidth);
				  selected.data('nodeSize', nodeSize);

				  // Remove inline width/height style to avoid conflicts
				  selected.style({
					width: '',
					height: ''
				  });

				saveData();
				closeEditModal();
			}

			function toggleSearchModal() {
				const modal = document.getElementById('searchModal');
				modal.classList.toggle('visible');
				modal.style.display = modal.style.display === 'none' ? 'block' : 'none';
				if (modal.style.display === 'block') {
					setTimeout(() => document.getElementById('searchInput').focus(), 100);
				}
			}

			function closeSearchModal() {
				document.getElementById('searchModal').style.display = 'none';
			}

			document.getElementById('searchInput').addEventListener('keypress', (e) => {
				if (e.key === 'Enter') performSearch();
			});

			function performSearch() {
				const query = document.getElementById('searchInput').value.trim().toLowerCase();
				searchResults = cy.nodes().filter((n) => n.data('label').toLowerCase().includes(query));
				searchIndex = 0;
				updateSearchFocus();
			}

			function updateSearchFocus() {
				if (searchResults.length === 0) {
					document.getElementById('searchIndex').textContent = '0 / 0';
					return;
				}
				const node = searchResults[searchIndex];
				cy.animate({
					fit: {
						eles: node
					},
					duration: 500
				});
				document.getElementById('searchIndex').textContent = `${searchIndex + 1} / ${
					searchResults.length
				}`;
			}

			function nextSearchResult() {
				if (searchResults.length === 0) return;
				searchIndex = (searchIndex + 1) % searchResults.length;
				updateSearchFocus();
			}

			function prevSearchResult() {
				if (searchResults.length === 0) return;
				searchIndex = (searchIndex - 1 + searchResults.length) % searchResults.length;
				updateSearchFocus();
			}

			function estimateSphereSize(text) {
				// Estimate based on square text area: sqrt(num of chars * area per char)
				const chars = text.length;
				const charArea = 25; // tweak as needed for visual balance (px^2 per char)
				const totalArea = chars * charArea;
				const side = Math.ceil(Math.sqrt(totalArea));
				const min = 80;
				const max = 300;
				return Math.min(max, Math.max(min, side));
			}

			function updateNodeIdCounter() {
				const allIds = cy
					.nodes()
					.map((n) => parseInt(n.id().slice(1)))
					.filter((n) => !isNaN(n));
				nodeId = allIds.length ? Math.max(...allIds) + 1 : 0;
			}

			function saveData() {
				const data = cy.elements().jsons();
				localStorage.setItem('thoughtMap', JSON.stringify(data));
				localStorage.setItem('thoughtWeb', JSON.stringify(data));
				console.log('Graph saved to localStorage');
			}

			function loadData() {
				const raw = localStorage.getItem('thoughtMap') || localStorage.getItem('thoughtWeb');

				if (!raw) {
					console.warn('No saved data found.');
					return [];
				} else if (!localStorage.getItem('thoughtMap')) {
					alert('Old save data detected. It will be upgraded to the new format.');
				}

				let parsed;
				try {
					parsed = JSON.parse(raw);
				} catch (err) {
					console.error('Failed to parse saved data:', err);
					return [];
				}

				const elements = Array.isArray(parsed)
					? parsed
					: Array.isArray(parsed.elements)
					? parsed.elements
					: [];

				if (!elements.length) {
					console.warn('No elements found in saved data.');
					return [];
				}

				const upgraded = elements.map((el) => {
					if (el.group === 'nodes') {
						const label = el.data?.label || '';

						// Patch data defaults
						el.data = {
							...el.data,
							parents: Array.isArray(el.data?.parents) ? el.data.parents : [],
							children: Array.isArray(el.data?.children) ? el.data.children : [],
							prompts: Array.isArray(el.data?.prompts) ? el.data.prompts : []
						};

					 // Make sure labelWidth and nodeSize exist and are numbers, else fallback
						if (typeof el.data.labelWidth !== 'number' || typeof el.data.nodeSize !== 'number') {
						  const { labelWidth, nodeSize } = calculateSquareTextBoxSize(el.data.label || '');
						  el.data.labelWidth = labelWidth;
						  el.data.nodeSize = nodeSize;
						}

						// Remove inline style overrides to let global style take control
						if (el.style) {
						  delete el.style.width;
						  delete el.style.height;
						}
					}
					return el;
				});

				console.log('Loaded elements:', upgraded);
				return upgraded;
			}

			function runAutoLayout() {
				cy.layout({ name: 'cose', animate: true }).run();
			}

			function addNode(text = null, position = null) {
				const input = document.getElementById('thoughtInput');
				const content = text || input.value.trim();
				if (!content) return;
				const id = `n${nodeId++}`;
				const { labelWidth, nodeSize } = calculateSquareTextBoxSize(content);


				if (!position) {
					const zoom = cy.zoom();
					const pan = cy.pan();
					const rect = cy.container().getBoundingClientRect();

					// Center of Cytoscape container in screen pixels
					const centerX = rect.width / 2;
					const centerY = rect.height / 2;

					// Convert center of container from screen pixels to graph coords
					const centerGraphPos = {
						x: (centerX - pan.x) / zoom,
						y: (centerY - pan.y) / zoom
					};

					// Find empty spot near centerGraphPos
					position = findEmptySpotNear(centerGraphPos);
				}

				cy.add({
					data: { id: id, label: content, labelWidth: labelWidth, nodeSize: nodeSize},
					position: position
				});

				if (!text) input.value = '';
				saveData();
			}



			function addLinkedNode() {
				if (selectionQueue.length !== 1) return alert('Select exactly one node to link from.');
				const input = document.getElementById('thoughtInput');
				const text = input.value.trim();
				if (!text) return;
				const fromId = selectionQueue[0].id();
				const id = `n${nodeId++}`;
				const size = estimateSphereSize(text);

				cy.add([
					{
						data: { id, label: text, size, parentId: fromId },
						position: findEmptySpotNear(selectionQueue[0].position())
					},
					{ data: { id: `e${fromId}_${id}`, source: fromId, target: id } }
				]);

				input.value = '';
				clearSelection();
				saveData();
			}

			function findEmptySpotNear(pos) {
				const offset = 150;

				// Check the center position first
				const centerConflict = cy.nodes().some((n) => {
					const np = n.position();
					return Math.hypot(np.x - pos.x, np.y - pos.y) < 100;
				});
				if (!centerConflict) return pos;

				// Check points around a circle offset from center
				for (let i = 0; i < 360; i += 30) {
					const angle = (i * Math.PI) / 180;
					const x = pos.x + Math.cos(angle) * offset;
					const y = pos.y + Math.sin(angle) * offset;
					const conflict = cy.nodes().some((n) => {
						const np = n.position();
						return Math.hypot(np.x - x, np.y - y) < 100;
					});
					if (!conflict) return { x, y };
				}
				// Fallback: just offset diagonally if no empty spot found
				return { x: pos.x + offset, y: pos.y + offset };
			}

			function generatePromptNodes() {
				if (selectionQueue.length !== 1) return;

				const parent = selectionQueue[0];
				const parentId = parent.id();

				let prompts = parent.data('prompts');

				// If prompts array is missing, generate and attach it
				if (!Array.isArray(prompts) || prompts.length === 0) {
					prompts = Array.from({ length: 3 + Math.floor(Math.random() * 3) }, (_, i) => ({
						id: `p${promptId++}`,
						text: `Prompt ${i + 1}`,
						answered: false
					}));

					parent.data('prompts', prompts);
					saveData();
				}

				// Remove any existing ghost nodes for clean re-render
				cy.nodes('.ghost-node').remove();

				const parentPos = parent.position();
				const radius = 120;

				// Render ghost nodes for unanswered prompts
				prompts.forEach((prompt, i) => {
					if (prompt.answered) return;

					const angle = ((2 * Math.PI) / prompts.length) * i;
					const pos = {
						x: parentPos.x + Math.cos(angle) * radius,
						y: parentPos.y + Math.sin(angle) * radius
					};

					cy.add([
						{
							group: 'nodes',
							data: {
								id: prompt.id,
								label: prompt.text,
								isGhost: true,
								parentId,
								prompt: prompt.text
							},
							position: pos,
							classes: 'ghost-node'
						},
						{
							group: 'edges',
							data: {
								id: `e${parentId}_${prompt.id}`,
								source: parentId,
								target: prompt.id
							}
						}
					]);
				});

				// Hide prompt lightbulb permanently after first click
				document.getElementById('promptButton').style.display = 'none';
			}

			function submitPromptAnswer() {
				const answer = document.getElementById('modalAnswer').value.trim();
				if (!answer || !currentPromptData || !currentPromptParent) return;

				const pos = currentPromptData.position();
				const parentId = currentPromptParent.id();
				const promptIdToRemove = currentPromptData.id();

				// Remove the ghost node
				cy.remove(currentPromptData);

				// Add real node from answer
				const size = estimateSphereSize(answer);
				const newNodeId = `n${nodeId++}`;

				cy.add([
					{
						data: {
							id: newNodeId,
							label: answer,
							size,
							parentId
						},
						style: { width: `${size}px`, height: `${size}px` },
						position: pos
					},
					{
						data: {
							id: `e${parentId}_${newNodeId}`,
							source: parentId,
							target: newNodeId
						}
					}
				]);

				// Mark the prompt as answered
				const prompts = currentPromptParent.data('prompts');
				const updated = prompts.map((p) => {
					if (p.id === promptIdToRemove) return { ...p, answered: true };
					return p;
				});
				currentPromptParent.data('prompts', updated);

				closePromptModal();
				saveData();
			}

			function closePromptModal() {
				document.getElementById('promptModal').style.display = 'none';
				currentPromptParent = null;
				currentPromptData = null;
			}

			function linkNodes() {
				if (selectionQueue.length !== 2) return alert('Select 2 nodes.');
				const [from, to] = selectionQueue;

				// Check if a link already exists
				const existingEdge = cy
					.edges()
					.filter(
						(edge) =>
							(edge.source().id() === from.id() && edge.target().id() === to.id()) ||
							(edge.source().id() === to.id() && edge.target().id() === from.id())
					)[0];

				if (existingEdge) {
					// Unlink
					cy.remove(existingEdge);
				} else {
					// Link
					cy.add({
						data: {
							id: `e${from.id()}_${to.id()}`,
							source: from.id(),
							target: to.id()
						}
					});
				}

				clearSelection();
				saveData();
				updateLinkButtonLabel();
			}

			function updateLinkButtonLabel() {
				const button = document.querySelector('button[onclick="linkNodes()"]');
				if (selectionQueue.length === 2) {
					const [from, to] = selectionQueue;
					const existingEdge = cy
						.edges()
						.some(
							(edge) =>
								(edge.source().id() === from.id() && edge.target().id() === to.id()) ||
								(edge.source().id() === to.id() && edge.target().id() === from.id())
						);
					button.textContent = existingEdge ? 'Unlink Selected Nodes' : 'Link Selected Nodes';
					button.onclick = linkNodes;
				} else if (selectionQueue.length === 1) {
					button.textContent = 'Edit Selected Node';
					button.onclick = openEditModal;
				} else {
					button.textContent = 'Link Selected Nodes';
					button.onclick = linkNodes;
				}
			}

			function deleteSelected() {
				selectionQueue.forEach((n) => n.remove());
				clearSelection();
				saveData();
			}

			function clearSelection() {
				selectionQueue.forEach((n) => {
					n.removeClass('manual-selected');
					n.ungrabify(); // prevent dragging when deselected
				});
				selectionQueue = [];
				document.getElementById('promptButton').style.display = 'none';
				cy.nodes('.ghost-node').remove();
			}

			function setupCustomSelection() {
				let isManualPanning = false;
				let lastPanPosition = null;

				// On pointer down on unselected node, begin manual pan
				cy.on('tapstart', 'node', (e) => {
					const node = e.target;

					// Only manual-pan if node is unselected and ungrabbable
					if (!node.hasClass('manual-selected')) {
						isManualPanning = true;
						const oe = e.originalEvent.touches?.[0] || e.originalEvent;
						lastPanPosition = { x: oe.clientX, y: oe.clientY };
					}
				});

				// Track pointer move and apply pan
				cy.on('tapdrag', (e) => {
					if (!isManualPanning || !lastPanPosition) return;

					const oe = e.originalEvent.touches?.[0] || e.originalEvent;
					const dx = oe.clientX - lastPanPosition.x;
					const dy = oe.clientY - lastPanPosition.y;

					const pan = cy.pan();
					cy.pan({
						x: pan.x + dx,
						y: pan.y + dy
					});

					lastPanPosition = { x: oe.clientX, y: oe.clientY };
				});

				// End pan on release
				cy.on('tapend', () => {
					isManualPanning = false;
					lastPanPosition = null;
				});

				cy.on('tap', 'node', function (e) {
					const node = e.target;
					if (node.hasClass('ghost-node')) return;

					if (selectionQueue.includes(node)) {
						node.removeClass('manual-selected');
						node.ungrabify();
						selectionQueue = selectionQueue.filter((n) => n !== node);
					} else {
						node.addClass('manual-selected');
						node.grabify();
						selectionQueue.push(node);
					}

					const promptBtn = document.getElementById('promptButton');
					if (selectionQueue.length === 1) {
						const selected = selectionQueue[0];
						const prompts = selected.data('prompts');

						// If prompts already exist and at least one is unanswered, show ghost nodes automatically
						if (Array.isArray(prompts) && prompts.some((p) => !p.answered)) {
							generatePromptNodes();
							promptBtn.style.display = 'none'; // Lightbulb should not reappear
						} else {
							promptBtn.style.display = 'flex'; // Show lightbulb only if no prompts yet
						}
					} else {
						promptBtn.style.display = 'none';
						cy.nodes('.ghost-node').remove();
					}

					updateLinkButtonLabel();
				});

				cy.on('tap', 'node.ghost-node', function (e) {
					const node = e.target;

					const parentId = node.data('parentId');
					const parent = cy.getElementById(parentId);

					if (!parent || !node.data('prompt')) return;

					currentPromptParent = parent;
					currentPromptData = node;

					// Populate modal with prompt content
					document.getElementById('modalPromptText').innerText = node.data('prompt');
					document.getElementById('modalAnswer').value = '';

					document.getElementById('promptModal').style.display = 'flex';
				});

				cy.on('tap', function (event) {
					if (event.target === cy) clearSelection();
				});

				let dragStartPosition = null;
				let lastDragPosition = null;
				let initialPositions = {};

				cy.on('grab', 'node', function (e) {
					const grabbed = e.target;
					if (!selectionQueue.includes(grabbed)) return;

					dragStartPosition = { ...grabbed.position() };
					lastDragPosition = { ...grabbed.position() };

					initialPositions = {};
					selectionQueue.forEach((n) => {
						initialPositions[n.id()] = { ...n.position() };
					});
				});

				cy.on('drag', 'node', function (e) {
					const dragged = e.target;
					if (!selectionQueue.includes(dragged)) return;
					if (!lastDragPosition) return;

					const current = dragged.position();
					const dx = current.x - lastDragPosition.x;
					const dy = current.y - lastDragPosition.y;

					selectionQueue.forEach((n) => {
						if (n.id() === dragged.id()) return;
						const pos = n.position();
						n.position({
							x: pos.x + dx,
							y: pos.y + dy
						});
					});

					lastDragPosition = { ...current };
				});

				cy.on('free', 'node', function (e) {
					const released = e.target;
					if (!selectionQueue.includes(released)) return;

					dragStartPosition = null;
					lastDragPosition = null;
					initialPositions = {};
					saveData();
				});
			}
		</script>
	</body>
</html>

